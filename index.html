<!DOCTYPE html>
<html lang="pl">
  <head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no, viewport-fit=cover" />
    <title>Kosmiczna Matematyka</title>
    <!-- PeerJS Library -->
    <script src="https://cdn.jsdelivr.net/npm/peerjs@1.5.4/dist/peerjs.min.js"></script>
    <!-- QR Code Library -->
    <script src="https://cdnjs.cloudflare.com/ajax/libs/qrcodejs/1.0.0/qrcode.min.js"></script>
    <style>
      * {
        margin: 0;
        padding: 0;
        box-sizing: border-box;
      }
      
      input, button, select, textarea {
        touch-action: manipulation;
      }

      body {
        font-family: "Comic Sans MS", cursive, sans-serif;
        background: #000;
        overflow: hidden;
        position: relative;
        width: 100vw;
        height: 100vh;
        -webkit-tap-highlight-color: transparent;
      }

      /* Animated cosmic background */
      .space-bg {
        position: fixed;
        top: 0;
        left: 0;
        width: 100%;
        height: 100%;
        background: radial-gradient(
            ellipse at 20% 30%,
            rgba(120, 81, 169, 0.3) 0%,
            transparent 50%
          ),
          radial-gradient(
            ellipse at 80% 70%,
            rgba(74, 144, 226, 0.3) 0%,
            transparent 50%
          ),
          radial-gradient(
            ellipse at 50% 50%,
            rgba(138, 43, 226, 0.2) 0%,
            transparent 70%
          ),
          linear-gradient(180deg, #0a0e27 0%, #1a0b2e 50%, #16213e 100%);
        z-index: 0;
        animation: cosmicPulse 15s ease-in-out infinite;
      }

      @keyframes cosmicPulse {
        0%,
        100% {
          opacity: 1;
        }
        50% {
          opacity: 0.8;
        }
      }

      .stars {
        position: fixed;
        top: 0;
        left: 0;
        width: 100%;
        height: 100%;
        pointer-events: none;
        z-index: 1;
      }

      .star {
        position: absolute;
        width: 2px;
        height: 2px;
        background: white;
        border-radius: 50%;
        animation: twinkle 3s infinite;
        box-shadow: 0 0 3px rgba(255, 255, 255, 0.5);
      }

      @keyframes twinkle {
        0%,
        100% {
          opacity: 0.3;
          transform: scale(1);
        }
        50% {
          opacity: 1;
          transform: scale(1.2);
        }
      }

      /* Setup screen */
      .setup-screen {
        position: fixed;
        top: 0;
        left: 0;
        width: 100%;
        height: 100%;
        background: rgba(10, 14, 39, 0.95);
        display: flex;
        align-items: center;
        justify-content: center;
        z-index: 1000;
      }

      .setup-container {
        background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
        padding: 40px;
        border-radius: 20px;
        box-shadow: 0 20px 60px rgba(0, 0, 0, 0.5),
          0 0 100px rgba(102, 126, 234, 0.3);
        max-width: 600px;
        width: 90%;
        border: 2px solid rgba(255, 255, 255, 0.2);
        position: relative;
      }

      .setup-title {
        text-align: center;
        font-size: 36px;
        color: white;
        margin-bottom: 30px;
        text-shadow: 3px 3px 6px rgba(0, 0, 0, 0.3),
          0 0 20px rgba(255, 255, 255, 0.5);
      }

      .player-setup {
        background: rgba(255, 255, 255, 0.95);
        padding: 20px;
        border-radius: 15px;
        margin-bottom: 15px;
        box-shadow: 0 4px 6px rgba(0, 0, 0, 0.1);
      }

      .player-setup h3 {
        color: #667eea;
        margin-bottom: 15px;
      }

      .player-setup input {
        width: 100%;
        padding: 12px;
        font-size: 16px;
        border: 2px solid #667eea;
        border-radius: 8px;
        margin-bottom: 10px;
        font-family: inherit;
      }

      .player-setup input.error {
        border-color: #ff6b6b;
      }

      .error-message {
        color: #ff6b6b;
        font-size: 14px;
        margin-top: -5px;
        margin-bottom: 10px;
        display: none;
      }

      .error-message.show {
        display: block;
      }

      .color-selector {
        display: grid;
        grid-template-columns: repeat(5, 1fr);
        gap: 8px;
        justify-items: center;
        margin-bottom: 10px;
      }

      .color-option {
        width: 45px;
        height: 45px;
        border-radius: 50%;
        border: 3px solid #ccc;
        cursor: pointer;
        transition: all 0.3s;
        box-shadow: 0 2px 4px rgba(0, 0, 0, 0.2);
      }

      .color-option:hover {
        transform: scale(1.15);
        box-shadow: 0 4px 8px rgba(0, 0, 0, 0.3);
      }

      .color-option.selected {
        border: 5px solid #333;
        transform: scale(1.2);
        box-shadow: 0 0 20px rgba(0, 0, 0, 0.5);
      }

      .color-option.disabled {
        opacity: 0.3;
        cursor: not-allowed;
      }

      .add-player-btn,
      .start-game-btn {
        width: 100%;
        padding: 15px;
        font-size: 18px;
        font-weight: bold;
        border: none;
        border-radius: 10px;
        cursor: pointer;
        margin-top: 10px;
        transition: all 0.3s;
        font-family: inherit;
        box-shadow: 0 4px 6px rgba(0, 0, 0, 0.2);
      }

      .add-player-btn {
        background: linear-gradient(135deg, #51cf66 0%, #40c057 100%);
        color: white;
      }

      .add-player-btn:hover {
        transform: translateY(-2px);
        box-shadow: 0 6px 12px rgba(0, 0, 0, 0.3);
      }

      .add-player-btn:disabled {
        background: #ccc;
        cursor: not-allowed;
        transform: none;
      }

      .start-game-btn {
        background: linear-gradient(135deg, #ff6b6b 0%, #fa5252 100%);
        color: white;
      }

      .start-game-btn:hover {
        transform: translateY(-2px);
        box-shadow: 0 6px 12px rgba(0, 0, 0, 0.3);
      }

      .start-game-btn:disabled {
        background: #ccc;
        cursor: not-allowed;
        transform: none;
      }

      /* Online Mode Button */
      .online-mode-btn {
        position: absolute;
        top: 20px;
        right: 20px;
        background: linear-gradient(135deg, #4dabf7 0%, #339af0 100%);
        color: white;
        border: none;
        padding: 15px 25px;
        border-radius: 12px;
        font-size: 18px;
        font-weight: bold;
        cursor: pointer;
        box-shadow: 0 4px 15px rgba(0, 0, 0, 0.3);
        border: 2px solid rgba(255, 255, 255, 0.5);
        z-index: 100;
        transition: all 0.3s;
        font-family: inherit;
      }

      .online-mode-btn:hover {
        transform: scale(1.05);
        box-shadow: 0 6px 20px rgba(0, 0, 0, 0.4);
      }

      /* Online Lobby */
      .online-lobby {
        display: none;
        position: fixed;
        top: 0;
        left: 0;
        width: 100%;
        height: 100%;
        background: rgba(10, 14, 39, 0.95);
        z-index: 2000;
        align-items: center;
        justify-content: center;
      }

      .online-lobby-content {
        background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
        padding: 40px;
        border-radius: 20px;
        box-shadow: 0 20px 60px rgba(0, 0, 0, 0.5);
        max-width: 600px;
        width: 90%;
        border: 2px solid rgba(255, 255, 255, 0.2);
        text-align: center;
      }

      .online-lobby-content h2 {
        color: white;
        font-size: 32px;
        margin-bottom: 20px;
        text-shadow: 2px 2px 4px rgba(0, 0, 0, 0.3);
      }

      .qr-container {
        background: white;
        padding: 20px;
        border-radius: 15px;
        margin: 20px auto;
        display: inline-block;
      }

      .players-waiting {
        background: rgba(255, 255, 255, 0.9);
        padding: 20px;
        border-radius: 15px;
        margin: 20px 0;
      }

      .players-waiting h3 {
        color: #667eea;
        margin-bottom: 15px;
      }

      .player-item {
        padding: 10px;
        margin: 5px 0;
        background: rgba(102, 126, 234, 0.1);
        border-radius: 8px;
        display: flex;
        align-items: center;
        gap: 10px;
      }

      .player-color-dot {
        width: 20px;
        height: 20px;
        border-radius: 50%;
        border: 2px solid white;
      }

      .start-online-btn {
        width: 100%;
        padding: 15px;
        font-size: 20px;
        font-weight: bold;
        background: linear-gradient(135deg, #51cf66 0%, #40c057 100%);
        color: white;
        border: none;
        border-radius: 10px;
        cursor: pointer;
        margin-top: 20px;
        font-family: inherit;
        box-shadow: 0 4px 6px rgba(0, 0, 0, 0.2);
      }

      .start-online-btn:disabled {
        background: #ccc;
        cursor: not-allowed;
      }

      .close-online-btn {
        background: rgba(255, 255, 255, 0.2);
        color: white;
        border: 2px solid white;
        padding: 10px 20px;
        border-radius: 8px;
        cursor: pointer;
        margin-top: 10px;
        font-family: inherit;
        font-size: 16px;
      }

      /* Game Screen */
      .game-screen {
        display: none;
        position: relative;
        width: 100%;
        height: 100%;
        z-index: 10;
      }

      .game-container {
        width: 100%;
        height: 100%;
        display: flex;
        flex-direction: column;
        align-items: center;
        justify-content: center;
        padding: 20px;
      }

      .title {
        font-size: 32px;
        color: white;
        text-shadow: 0 0 20px rgba(102, 126, 234, 0.8),
          3px 3px 6px rgba(0, 0, 0, 0.5);
        margin-bottom: 20px;
        text-align: center;
      }

      .board-wrapper {
        position: relative;
        background: rgba(255, 255, 255, 0.05);
        border-radius: 20px;
        padding: 30px;
        box-shadow: 0 10px 50px rgba(0, 0, 0, 0.5),
          0 0 100px rgba(102, 126, 234, 0.2);
        border: 2px solid rgba(255, 255, 255, 0.1);
        margin-bottom: 20px;
      }

      .board {
        position: relative;
        width: 800px;
        height: 600px;
        background: rgba(10, 14, 39, 0.8);
        border-radius: 15px;
        border: 3px solid rgba(102, 126, 234, 0.5);
        box-shadow: inset 0 0 50px rgba(102, 126, 234, 0.1);
      }

      /* Card Decks - OUTSIDE the board */
      .card-decks {
        position: fixed;
        bottom: 50px;
        left: 50px;
        display: flex;
        gap: 20px;
        z-index: 150;
      }

      .card-deck {
        position: relative;
        width: 70px;
        height: 100px;
      }

      .deck-card {
        position: absolute;
        width: 70px;
        height: 100px;
        background: white;
        border-radius: 10px;
        border: 4px solid rgba(0, 0, 0, 0.4);
        display: flex;
        align-items: center;
        justify-content: center;
        font-size: 45px;
        box-shadow: 0 6px 12px rgba(0, 0, 0, 0.4);
        transition: all 0.3s;
      }

      .deck-card.white {
        background: linear-gradient(135deg, #e9ecef 0%, #dee2e6 100%);
        color: #333;
      }

      .deck-card.green {
        background: linear-gradient(135deg, #51cf66 0%, #40c057 100%);
        color: white;
      }

      .deck-card.yellow {
        background: linear-gradient(135deg, #ffd43b 0%, #fcc419 100%);
        color: #333;
      }

      .deck-card.red {
        background: linear-gradient(135deg, #ff6b6b 0%, #fa5252 100%);
        color: white;
      }

      /* Card animation */
      @keyframes cardDrawAwesome {
        0% {
          transform: translate(0, 0) scale(1) rotate(0deg);
          opacity: 1;
        }
        40% {
          transform: translate(600px, -350px) scale(1.8) rotate(360deg);
          opacity: 1;
        }
        60% {
          transform: translate(600px, -350px) scale(1.8) rotate(360deg);
          opacity: 1;
        }
        100% {
          transform: translate(600px, -350px) scale(0) rotate(720deg);
          opacity: 0;
        }
      }

      .card-drawing {
        animation: cardDrawAwesome 1.2s ease-in-out forwards;
        z-index: 3000;
      }

      /* Space styling */
      .space {
        position: absolute;
        width: 40px;
        height: 40px;
        border-radius: 50%;
        border: 3px solid rgba(255, 255, 255, 0.3);
        display: flex;
        align-items: center;
        justify-content: center;
        font-weight: bold;
        box-shadow: 0 0 15px rgba(255, 255, 255, 0.3);
        transition: all 0.3s;
      }

      .space.white {
        background: linear-gradient(135deg, #e9ecef 0%, #dee2e6 100%);
        color: #333;
      }

      .space.green {
        background: linear-gradient(135deg, #51cf66 0%, #40c057 100%);
        color: white;
        box-shadow: 0 0 20px rgba(81, 207, 102, 0.6);
      }

      .space.yellow {
        background: linear-gradient(135deg, #ffd43b 0%, #fcc419 100%);
        color: #333;
        box-shadow: 0 0 20px rgba(255, 212, 59, 0.6);
      }

      .space.red {
        background: linear-gradient(135deg, #ff6b6b 0%, #fa5252 100%);
        color: white;
        box-shadow: 0 0 20px rgba(255, 107, 107, 0.6);
      }

      .space.purple {
        background: linear-gradient(135deg, #9b59b6 0%, #8e44ad 100%);
        color: white;
        box-shadow: 0 0 20px rgba(155, 89, 182, 0.8);
        font-size: 28px;
        font-weight: 900;
      }

      /* Path connections */
      .path-line {
        stroke: rgba(255, 255, 255, 0.3);
        stroke-width: 3;
        fill: none;
        filter: drop-shadow(0 0 5px rgba(255, 255, 255, 0.5));
      }

      .teleport-line {
        stroke: white;
        stroke-width: 5;
        fill: none;
        stroke-dasharray: 10, 5;
        filter: drop-shadow(0 0 10px rgba(255, 255, 255, 1));
        opacity: 0;
        animation: teleportFlash 0.8s ease-in-out infinite;
      }

      @keyframes teleportFlash {
        0%,
        100% {
          opacity: 0;
        }
        50% {
          opacity: 1;
        }
      }

      /* Player pieces */
      .player-piece {
        position: absolute;
        width: 30px;
        height: 30px;
        border-radius: 50%;
        border: 3px solid white;
        transition: left 0.15s cubic-bezier(0.68, -0.55, 0.265, 1.55),
          top 0.15s cubic-bezier(0.68, -0.55, 0.265, 1.55), transform 0.1s ease;
        z-index: 100;
        box-shadow: 0 0 15px rgba(0, 0, 0, 0.5), 0 0 30px currentColor;
        animation: playerGlow 2s ease-in-out infinite;
      }

      @keyframes playerGlow {
        0%,
        100% {
          box-shadow: 0 0 15px rgba(0, 0, 0, 0.5), 0 0 20px currentColor;
        }
        50% {
          box-shadow: 0 0 20px rgba(0, 0, 0, 0.7), 0 0 35px currentColor;
        }
      }

      /* Markers */
      .start-marker {
        position: absolute;
        left: 25px;
        top: 25px;
        background: linear-gradient(135deg, #51cf66 0%, #40c057 100%);
        color: white;
        padding: 8px 15px;
        border-radius: 10px;
        font-weight: bold;
        font-size: 14px;
        box-shadow: 0 0 20px rgba(81, 207, 102, 0.8);
        border: 2px solid rgba(255, 255, 255, 0.5);
        z-index: 200;
      }

      .finish-marker {
        position: absolute;
        left: 25px;
        bottom: 25px;
        background: linear-gradient(135deg, #ff6b6b 0%, #fa5252 100%);
        color: white;
        padding: 8px 15px;
        border-radius: 10px;
        font-weight: bold;
        font-size: 14px;
        box-shadow: 0 0 30px rgba(255, 107, 107, 1);
        border: 2px solid rgba(255, 255, 255, 0.5);
        z-index: 200;
        animation: finishPulse 2s ease-in-out infinite;
      }

      @keyframes finishPulse {
        0%,
        100% {
          transform: scale(1);
        }
        50% {
          transform: scale(1.1);
        }
      }

      /* Controls */
      .controls {
        text-align: center;
        background: rgba(255, 255, 255, 0.1);
        padding: 20px;
        border-radius: 15px;
        border: 2px solid rgba(255, 255, 255, 0.2);
      }

      .current-player {
        font-size: 24px;
        color: white;
        margin-bottom: 15px;
        text-shadow: 0 0 10px rgba(255, 255, 255, 0.5);
      }

      .btn {
        background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
        color: white;
        border: none;
        padding: 15px 30px;
        font-size: 20px;
        font-weight: bold;
        border-radius: 10px;
        cursor: pointer;
        transition: all 0.3s;
        box-shadow: 0 5px 15px rgba(0, 0, 0, 0.3);
        font-family: inherit;
      }

      .btn:hover:not(:disabled) {
        transform: translateY(-2px);
        box-shadow: 0 7px 20px rgba(0, 0, 0, 0.4);
      }

      .btn:active:not(:disabled) {
        transform: translateY(0);
      }

      .btn:disabled {
        opacity: 0.5;
        cursor: not-allowed;
      }

      .dice-result {
        margin-top: 15px;
        font-size: 20px;
        color: white;
        min-height: 30px;
      }

      /* Question Modal */
      .question-modal {
        display: none;
        position: fixed;
        top: 0;
        left: 0;
        width: 100%;
        height: 100%;
        background: rgba(0, 0, 0, 0.8);
        align-items: center;
        justify-content: center;
        z-index: 2000;
      }

      .question-content {
        background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
        padding: 40px;
        border-radius: 20px;
        box-shadow: 0 20px 60px rgba(0, 0, 0, 0.5);
        text-align: center;
        max-width: 500px;
        width: 90%;
        border: 3px solid rgba(255, 255, 255, 0.3);
        position: relative;
      }

      .question-timer {
        position: absolute;
        top: 15px;
        right: 15px;
        background: rgba(255, 255, 255, 0.9);
        color: #667eea;
        padding: 8px 15px;
        border-radius: 8px;
        font-weight: bold;
        font-size: 18px;
        box-shadow: 0 2px 10px rgba(0, 0, 0, 0.2);
      }

      .question-timer.warning {
        background: #ffd43b;
        color: #333;
        animation: timerPulse 0.5s ease-in-out infinite;
      }

      .question-timer.danger {
        background: #ff6b6b;
        color: white;
        animation: timerPulse 0.3s ease-in-out infinite;
      }

      @keyframes timerPulse {
        0%,
        100% {
          transform: scale(1);
        }
        50% {
          transform: scale(1.1);
        }
      }

      .question-content h2 {
        color: white;
        font-size: 28px;
        margin-bottom: 25px;
        text-shadow: 2px 2px 4px rgba(0, 0, 0, 0.3);
        transition: opacity 0.2s ease;
      }

      .question-content input {
        width: 100%;
        padding: 15px;
        font-size: 20px;
        border: none;
        border-radius: 10px;
        margin-bottom: 20px;
        text-align: center;
        font-family: inherit;
      }

      .question-content button {
        width: 100%;
        padding: 15px;
        font-size: 20px;
        font-weight: bold;
        background: linear-gradient(135deg, #51cf66 0%, #40c057 100%);
        color: white;
        border: none;
        border-radius: 10px;
        cursor: pointer;
        transition: all 0.3s;
        box-shadow: 0 4px 6px rgba(0, 0, 0, 0.2);
        font-family: inherit;
      }

      .question-content button:hover:not(:disabled) {
        transform: translateY(-2px);
        box-shadow: 0 6px 12px rgba(0, 0, 0, 0.3);
      }

      .question-content button:disabled {
        opacity: 0.5;
        cursor: not-allowed;
      }

      .correct-answer {
        margin-top: 15px;
        padding: 15px;
        background: rgba(255, 255, 255, 0.9);
        border-radius: 10px;
        font-size: 18px;
        font-weight: bold;
        color: #667eea;
        display: none;
      }

      /* Dice Animation */
      .dice-animation {
        display: none;
        position: fixed;
        top: 50%;
        left: 50%;
        transform: translate(-50%, -50%);
        width: 150px;
        height: 150px;
        background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
        border-radius: 20px;
        box-shadow: 0 20px 60px rgba(0, 0, 0, 0.5);
        z-index: 3000;
        animation: diceRoll 0.5s ease-in-out;
        border: 5px solid rgba(255, 255, 255, 0.5);
      }

      @keyframes diceRoll {
        0%,
        100% {
          transform: translate(-50%, -50%) rotate(0deg);
        }
        25% {
          transform: translate(-50%, -50%) rotate(90deg);
        }
        50% {
          transform: translate(-50%, -50%) rotate(180deg);
        }
        75% {
          transform: translate(-50%, -50%) rotate(270deg);
        }
      }

      .dice-number {
        width: 100%;
        height: 100%;
        display: flex;
        align-items: center;
        justify-content: center;
        font-size: 80px;
        color: white;
        font-weight: bold;
        text-shadow: 3px 3px 6px rgba(0, 0, 0, 0.3);
      }

      /* Temporary Notification */
      .temp-notification {
        display: none;
        position: fixed;
        top: 50%;
        left: 50%;
        transform: translate(-50%, -50%);
        background: white;
        color: #333;
        padding: 30px 50px;
        border-radius: 15px;
        font-size: 24px;
        font-weight: bold;
        box-shadow: 0 10px 40px rgba(0, 0, 0, 0.5);
        z-index: 3500;
        text-align: center;
        white-space: pre-line;
      }

      .temp-notification.success {
        background: linear-gradient(135deg, #51cf66 0%, #40c057 100%);
        color: white;
      }

      .temp-notification.error {
        background: linear-gradient(135deg, #ff6b6b 0%, #fa5252 100%);
        color: white;
      }

      /* Instructions Button and Panel */
      .instructions-toggle {
        position: absolute;
        top: 20px;
        right: 20px;
        background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
        color: white;
        border: none;
        padding: 12px 20px;
        border-radius: 10px;
        font-size: 20px;
        font-weight: bold;
        cursor: pointer;
        box-shadow: 0 4px 15px rgba(0, 0, 0, 0.3);
        border: 2px solid rgba(255, 255, 255, 0.5);
        z-index: 150;
        transition: all 0.3s;
        font-family: inherit;
      }

      .instructions-toggle:hover {
        transform: scale(1.05);
        box-shadow: 0 6px 20px rgba(0, 0, 0, 0.4);
      }

      .instructions-panel {
        position: absolute;
        top: 70px;
        right: 20px;
        background: rgba(255, 255, 255, 0.95);
        padding: 0;
        border-radius: 12px;
        font-size: 13px;
        line-height: 1.6;
        box-shadow: 0 4px 15px rgba(0, 0, 0, 0.3);
        border: 2px solid rgba(102, 126, 234, 0.5);
        max-width: 280px;
        z-index: 149;
        max-height: 0;
        overflow-y: auto;
        overflow-x: hidden;
        opacity: 0;
        transition: max-height 0.5s ease, opacity 0.4s ease, padding 0.5s ease;
      }

      .instructions-panel.open {
        max-height: 500px;
        opacity: 1;
        padding: 20px;
      }

      .instructions-panel h3 {
        color: #667eea;
        margin-bottom: 10px;
        font-size: 16px;
        border-bottom: 2px solid #667eea;
        padding-bottom: 5px;
      }

      .instructions-panel p {
        margin-bottom: 10px;
      }

      .instructions-panel .rule-item {
        margin-bottom: 8px;
        padding-left: 5px;
      }

      .instructions-panel strong {
        color: #667eea;
      }

      /* Mobile Player Interface */
      .mobile-player-screen {
        display: none;
        width: 100%;
        min-height: 100vh;
        padding: 20px;
        color: white;
        text-align: center;
        overflow-y: auto;
        overflow-x: hidden;
        z-index: 3000;
        -webkit-overflow-scrolling: touch;
        pointer-events: none;
      }

      .mobile-player-screen.active {
        display: flex;
        flex-direction: column;
        align-items: center;
        justify-content: center;
        pointer-events: auto;
      }

      .mobile-player-screen h1 {
        font-size: 24px;
        margin-bottom: 20px;
        text-shadow: 0 0 20px rgba(102, 126, 234, 0.8);
      }
      
      .mobile-player-screen h2 {
        font-size: 20px;
        margin-bottom: 20px;
      }

      .mobile-player-screen input {
        width: 100%;
        max-width: 400px;
        padding: 15px;
        font-size: 16px;
        border: 3px solid #667eea;
        border-radius: 10px;
        margin-bottom: 20px;
        font-family: inherit;
        text-align: center;
        -webkit-user-select: text;
        user-select: text;
        touch-action: manipulation;
        -webkit-appearance: none;
        appearance: none;
        background: white;
      }
      
      .mobile-player-screen input:focus {
        outline: none;
        border-color: #51cf66;
        touch-action: manipulation;
        background: white;
      }

      .mobile-color-selector {
        display: grid;
        grid-template-columns: repeat(4, 1fr);
        gap: 15px;
        margin-bottom: 30px;
        max-width: 400px;
        width: 100%;
        touch-action: manipulation;
      }

      .mobile-color-option {
        width: 100%;
        aspect-ratio: 1;
        border-radius: 50%;
        border: 4px solid rgba(255, 255, 255, 0.3);
        cursor: pointer;
        transition: all 0.2s ease-out;
        touch-action: manipulation;
        -webkit-tap-highlight-color: transparent;
        will-change: transform;
        transform: translateZ(0);
        -webkit-transform: translateZ(0);
      }
      
      .mobile-color-option:active:not(.disabled) {
        transform: translateZ(0) scale(0.95);
        -webkit-transform: translateZ(0) scale(0.95);
      }

      .mobile-color-option.selected {
        border: 5px solid white;
        transform: translateZ(0) scale(1.15);
        -webkit-transform: translateZ(0) scale(1.15);
        box-shadow: 0 0 20px rgba(255, 255, 255, 0.8);
      }

      .mobile-color-option.disabled {
        opacity: 0.25;
        cursor: not-allowed;
        pointer-events: none;
        filter: grayscale(100%);
      }

      .mobile-btn {
        width: 100%;
        max-width: 400px;
        padding: 18px;
        font-size: 20px;
        font-weight: bold;
        background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
        color: white;
        border: none;
        border-radius: 12px;
        cursor: pointer;
        font-family: inherit;
        box-shadow: 0 5px 15px rgba(0, 0, 0, 0.3);
        transition: transform 0.1s ease-out;
        margin: 10px 0;
        touch-action: manipulation;
        -webkit-tap-highlight-color: transparent;
        will-change: transform;
        transform: translateZ(0);
        -webkit-transform: translateZ(0);
      }

      .mobile-btn:active:not(:disabled) {
        transform: translateZ(0) scale(0.97);
        -webkit-transform: translateZ(0) scale(0.97);
      }

      .mobile-btn:disabled {
        opacity: 0.5;
        cursor: not-allowed;
        background: #999;
        transform: none !important;
        -webkit-transform: none !important;
      }

      .mobile-btn.roll {
        background: linear-gradient(135deg, #51cf66 0%, #40c057 100%);
        font-size: 32px;
        padding: 40px;
      }

      .status-message {
        background: rgba(255, 255, 255, 0.1);
        padding: 20px;
        border-radius: 12px;
        margin: 20px 0;
        font-size: 18px;
        max-width: 400px;
        width: 100%;
      }

      .players-list {
        background: rgba(255, 255, 255, 0.1);
        padding: 20px;
        border-radius: 12px;
        margin: 20px 0;
        max-width: 400px;
        width: 100%;
      }

      .current-turn {
        background: rgba(81, 207, 102, 0.3);
        border: 2px solid #51cf66;
      }

      .question-box {
        background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
        padding: 30px;
        border-radius: 15px;
        margin: 20px 0;
        max-width: 400px;
        width: 100%;
      }
      
      .question-box input {
        -webkit-user-select: text;
        user-select: text;
        -webkit-appearance: none;
        appearance: none;
      }
      
      .question-box input:focus {
        outline: none;
        border: 3px solid #51cf66;
      }

      .question-text {
        font-size: 28px;
        margin: 20px 0;
        text-shadow: 2px 2px 4px rgba(0, 0, 0, 0.3);
        word-wrap: break-word;
        overflow-wrap: break-word;
      }

      .timer {
        font-size: 24px;
        font-weight: bold;
        margin: 10px 0;
        padding: 10px;
        background: rgba(255, 255, 255, 0.2);
        border-radius: 8px;
      }

      .timer.warning {
        background: #ffd43b;
        color: #333;
      }

      .timer.danger {
        background: #ff6b6b;
        animation: pulse 0.5s infinite;
      }

      @keyframes pulse {
        0%, 100% { transform: scale(1); }
        50% { transform: scale(1.1); }
      }

      .success-message {
        background: #51cf66;
        color: white;
        padding: 15px;
        border-radius: 10px;
        margin: 20px 0;
        font-size: 20px;
        max-width: 400px;
        width: 100%;
      }

      .error-msg {
        background: #ff6b6b;
        color: white;
        padding: 15px;
        border-radius: 10px;
        margin: 20px 0;
        max-width: 400px;
        width: 100%;
      }

      .loading {
        font-size: 18px;
        opacity: 0.7;
        animation: blink 1.5s infinite;
      }

      @keyframes blink {
        0%, 100% { opacity: 0.7; }
        50% { opacity: 0.3; }
      }
    </style>
  </head>
  <body>
    <!-- Space background -->
    <div class="space-bg"></div>
    <div class="stars" id="stars"></div>

    <!-- Setup Screen (Local Mode) -->
    <div class="setup-screen" id="setupScreen">
      <button class="online-mode-btn" onclick="openOnlineMode()">
        üåê TRYB ONLINE
      </button>
      <div class="setup-container">
        <div class="setup-title">üöÄ Kosmiczna Matematyka üåü</div>
        <div id="playersContainer"></div>
        <button class="add-player-btn" id="addPlayerBtn" onclick="addPlayer()">
          ‚ûï Dodaj Gracza
        </button>
        <button class="start-game-btn" id="startGameBtn" onclick="startGame()" disabled>
          üéÆ START GRY
        </button>
      </div>
    </div>

    <!-- Online Lobby -->
    <div class="online-lobby" id="onlineLobby">
      <div class="online-lobby-content">
        <h2>üåê Tryb Online</h2>
        <p style="color: white; margin-bottom: 20px;" id="onlineStatusText">≈ÅƒÖczenie...</p>
        
        <div class="qr-container" id="qrContainer">
          <div id="qrcode">
            <p style="color: #333;">≈Åadowanie kodu QR...</p>
          </div>
        </div>

        <div class="players-waiting">
          <h3>Gracze w poczekalni:</h3>
          <div id="playersWaitingList">
            <p style="color: #999;">Czekam na graczy...</p>
          </div>
        </div>

        <button class="start-online-btn" id="startOnlineBtn" onclick="startOnlineGame()" disabled>
          üéÆ START GRY (min. 2 graczy)
        </button>

        <button class="close-online-btn" onclick="closeOnlineMode()">
          ‚úï Zamknij
        </button>
      </div>
    </div>

    <!-- Game Screen (Local + Online Host) -->
    <div class="game-screen" id="gameScreen">
      <!-- Card Decks -->
      <div class="card-decks">
        <div class="card-deck" id="whiteDeck">
          <div class="deck-card white">‚ùì</div>
        </div>
        <div class="card-deck" id="greenDeck">
          <div class="deck-card green">‚ùì</div>
        </div>
        <div class="card-deck" id="yellowDeck">
          <div class="deck-card yellow">‚ùì</div>
        </div>
        <div class="card-deck" id="redDeck">
          <div class="deck-card red">‚ùì</div>
        </div>
      </div>

      <div class="game-container">
        <div class="title">üöÄ Kosmiczna Matematyka üåü</div>

        <div class="board-wrapper">
          <div class="board" id="board">
            <div class="start-marker">START üöÄ</div>
            <div class="finish-marker">META üèÅ</div>

            <button class="instructions-toggle" onclick="toggleInstructions()">
              üìñ ZASADY
            </button>

            <div class="instructions-panel" id="instructionsPanel">
              <h3>üìñ Zasady Gry</h3>
              <p>
                <strong>üéØ Cel gry:</strong><br />
                Jako pierwszy dotrzeƒá do METY üèÅ!
              </p>
              <p>
                <strong>üé≤ Rozgrywka:</strong><br />
                ‚Ä¢ Gracze rzucajƒÖ kostkƒÖ po kolei<br />
                ‚Ä¢ Poruszasz siƒô o wyrzuconƒÖ liczbƒô p√≥l<br />
                ‚Ä¢ ≈öcie≈ºka biegnie wƒô≈ºykiem
              </p>
              <p>
                <strong>‚è±Ô∏è CZAS NA ODPOWIED≈π:</strong><br />
                ‚Ä¢ Bia≈Çe: 30 sek<br />
                ‚Ä¢ ≈Åatwe: 30 sek<br />
                ‚Ä¢ ≈örednie: 60 sek<br />
                ‚Ä¢ Trudne: 90 sek<br />
                ‚Ä¢ Fioletowe: 90 sek
              </p>
              <p>
                <strong>‚ö™ BIA≈ÅE:</strong><br />
                Dobra: Zostajesz w miejscu<br />
                Z≈Ça: -4 pola
              </p>
              <p>
                <strong>üü¢ ≈ÅATWE:</strong><br />
                Dobra: +1 pole<br />
                Z≈Ça: -3 pola
              </p>
              <p>
                <strong>üü° ≈öREDNIE:</strong><br />
                Dobra: +2 pola + BONUS RZUT<br />
                Z≈Ça: -2 pola
              </p>
              <p>
                <strong>üî¥ TRUDNE:</strong><br />
                Dobra: +3 pola + BONUS RZUT<br />
                Z≈Ça: -1 pole
              </p>
              <p>
                <strong>üü£ TELEPORT:</strong><br />
                Dobra: TELEPORTACJA<br />
                Z≈Ça: Zostajesz na miejscu
              </p>
            </div>
          </div>
        </div>

        <div class="controls" id="localControls">
          <div class="current-player" id="currentPlayer"></div>
          <button class="btn" id="rollDiceBtn" onclick="rollDice()">üé≤ RZUƒÜ KOSTKƒÑ</button>
          <div class="dice-result" id="diceResult"></div>
        </div>
      </div>
    </div>

    <!-- Mobile Player Screens -->
    <!-- Join Screen -->
    <div class="mobile-player-screen" id="mobileJoinScreen">
      <h1>üöÄ Kosmiczna Matematyka</h1>
      <h2 style="margin-bottom: 30px;">Do≈ÇƒÖcz do gry!</h2>
      
      <div id="mobileLoadingMsg" style="color: #ffd43b; margin-bottom: 20px; font-size: 16px;">
        ‚è≥ ≈ÅƒÖczenie...
      </div>
      
      <input type="text" id="mobilePlayerName" placeholder="Wpisz swoje imiƒô" maxlength="15" autocomplete="off" autocorrect="off" autocapitalize="words" />
      
      <div class="mobile-color-selector" id="mobileColorSelector">
        <div class="mobile-color-option" data-color="blue" style="background: #4dabf7;"></div>
        <div class="mobile-color-option" data-color="red" style="background: #ff6b6b;"></div>
        <div class="mobile-color-option" data-color="green" style="background: #51cf66;"></div>
        <div class="mobile-color-option" data-color="yellow" style="background: #ffd43b;"></div>
        <div class="mobile-color-option" data-color="purple" style="background: #9b59b6;"></div>
        <div class="mobile-color-option" data-color="orange" style="background: #ff922b;"></div>
        <div class="mobile-color-option" data-color="pink" style="background: #ff6ba9;"></div>
        <div class="mobile-color-option" data-color="cyan" style="background: #22b8cf;"></div>
      </div>

      <button class="mobile-btn" id="mobileJoinBtn" disabled>Do≈ÇƒÖcz do gry</button>
      <div id="mobileJoinError" class="error-msg" style="display: none;"></div>
    </div>

    <!-- Waiting Screen -->
    <div class="mobile-player-screen" id="mobileWaitingScreen">
      <h1>üöÄ Kosmiczna Matematyka</h1>
      <div class="success-message">‚úì Po≈ÇƒÖczono!</div>
      <div class="status-message">
        Czekam na rozpoczƒôcie gry...<br>
        <span class="loading">‚óè‚óè‚óè</span>
      </div>
    </div>

    <!-- Game Screen -->
    <div class="mobile-player-screen" id="mobileGameScreen">
      <h1>üöÄ Kosmiczna Matematyka</h1>
      <div class="players-list" id="mobilePlayersList"></div>
      <div id="mobileTurnMessage" class="status-message"></div>
      <button class="mobile-btn roll" id="mobileRollBtn" disabled>
        üé≤ RZUƒÜ KOSTKƒÑ
      </button>
    </div>

    <!-- Question Screen -->
    <div class="mobile-player-screen" id="mobileQuestionScreen">
      <h1>üöÄ Kosmiczna Matematyka</h1>
      <div class="question-box">
        <div class="timer" id="mobileTimer">0:00</div>
        <div class="question-text" id="mobileQuestionText"></div>
        <input type="number" id="mobileAnswerInput" placeholder="Wpisz odpowied≈∫" autocomplete="off" inputmode="numeric" pattern="[0-9]*" />
        <button class="mobile-btn" id="mobileSubmitBtn">
          ‚úì SPRAWD≈π
        </button>
      </div>
    </div>

    <!-- Winner Screen -->
    <div class="mobile-player-screen" id="mobileWinnerScreen">
      <h1>üèÜ KONIEC GRY! üèÜ</h1>
      <div class="success-message" id="mobileWinnerMessage"></div>
      <button class="mobile-btn" id="mobileReloadBtn">
        üîÑ Zagraj ponownie
      </button>
    </div>

    <!-- Question Modal (Local Mode) -->
    <div class="question-modal" id="questionModal">
      <div class="question-content">
        <div class="question-timer" id="questionTimer">0:00</div>
        <h2 id="questionText"></h2>
        <input type="number" id="answerInput" placeholder="Wpisz odpowied≈∫" autocomplete="off" />
        <div class="correct-answer" id="correctAnswer"></div>
        <button id="checkAnswerBtn" onclick="checkAnswer()">‚úì SPRAWD≈π</button>
      </div>
    </div>

    <!-- Dice Animation -->
    <div class="dice-animation" id="diceAnimation">
      <div class="dice-number" id="diceNumber">6</div>
    </div>

    <!-- Temporary Notification -->
    <div class="temp-notification" id="tempNotification"></div>

    <script>
      // Create stars
      function createStars() {
        const starsContainer = document.getElementById("stars");
        for (let i = 0; i < 300; i++) {
          const star = document.createElement("div");
          star.className = "star";
          star.style.left = Math.random() * 100 + "%";
          star.style.top = Math.random() * 100 + "%";
          star.style.animationDelay = Math.random() * 3 + "s";
          starsContainer.appendChild(star);
        }
      }
      createStars();

      // Check if this is mobile player mode
      const urlParams = new URLSearchParams(window.location.search);
      const roomId = urlParams.get('room');
      const isMobilePlayer = !!roomId;

      if (isMobilePlayer) {
        // Hide desktop interface, show mobile interface
        document.getElementById('setupScreen').style.display = 'none';
        document.getElementById('mobileJoinScreen').classList.add('active');
        
        // Wait for libraries to load - increased timeout
        setTimeout(() => {
          initMobilePlayer(roomId);
        }, 1000);
      } else {
        // Normal desktop mode
        window.addEventListener("load", () => {
          addPlayer();
        });
      }

      // Math problems
      const mathProblems = {
        white: [
          { q: "15+23", a: 38 }, { q: "42-17", a: 25 }, { q: "28+31", a: 59 },
          { q: "65-28", a: 37 }, { q: "19+24", a: 43 }, { q: "51-19", a: 32 },
          { q: "33+45", a: 78 }, { q: "74-29", a: 45 }, { q: "26+38", a: 64 },
          { q: "81-34", a: 47 }, { q: "47+21", a: 68 }, { q: "93-48", a: 45 }
        ],
        green: [
          { q: "7√ó4", a: 28 }, { q: "48√∑8", a: 6 }, { q: "9√ó6", a: 54 },
          { q: "56√∑7", a: 8 }, { q: "8√ó5", a: 40 }, { q: "72√∑9", a: 8 },
          { q: "6√ó7", a: 42 }, { q: "63√∑9", a: 7 }, { q: "4√ó9", a: 36 }
        ],
        yellow: [
          { q: "12√ó6", a: 72 }, { q: "96√∑12", a: 8 }, { q: "14√ó4", a: 56 },
          { q: "48√∑6", a: 8 }, { q: "11√ó5", a: 55 }, { q: "66√∑11", a: 6 },
          { q: "13√ó4", a: 52 }, { q: "39√∑3", a: 13 }, { q: "15√ó3", a: 45 }
        ],
        red: [
          { q: "17√ó8", a: 136 }, { q: "144√∑12", a: 12 }, { q: "23√ó5", a: 115 },
          { q: "132√∑11", a: 12 }, { q: "19√ó7", a: 133 }, { q: "156√∑13", a: 12 },
          { q: "21√ó6", a: 126 }, { q: "168√∑14", a: 12 }, { q: "24√ó7", a: 168 }
        ],
      };

      // Generate board path
      function generateBoardPath() {
        const path = [];
        const cols = 16;
        const rows = 10;
        const startX = 60;
        const startY = 80;
        const spaceX = 45;
        const spaceY = 50;
        let lastQuestionIndex = -10;

        for (let row = 0; row < rows; row++) {
          for (let col = 0; col < cols; col++) {
            let x, y;
            let arrow = null;
            const currentIndex = row * cols + col;

            if (row % 2 === 0) {
              x = startX + col * spaceX;
              if (col > 0 && col < cols - 1 && col % 4 === 0) {
                arrow = "‚Üí";
              }
            } else {
              x = startX + (cols - 1 - col) * spaceX;
              if (col > 0 && col < cols - 1 && col % 4 === 0) {
                arrow = "‚Üê";
              }
            }

            y = startY + row * spaceY;

            if (row % 2 === 0 && col === cols - 1 && row < rows - 1) {
              arrow = "‚Üì";
            }
            if (row % 2 === 1 && col === 0 && row < rows - 1) {
              arrow = "‚Üì";
            }

            let color = "white";

            if (currentIndex > 0 && currentIndex < cols * rows - 1) {
              if (currentIndex - lastQuestionIndex >= 4) {
                const rand = Math.random();
                if (rand < 0.3) {
                  const questionRand = Math.random();
                  if (questionRand < 0.45) {
                    color = "green";
                  } else if (questionRand < 0.8) {
                    color = "yellow";
                  } else {
                    color = "red";
                  }
                  lastQuestionIndex = currentIndex;
                }
              }
            }

            path.push({ x, y, color, arrow });
          }
        }

        const teleportPositions = [
          { from: 24, to: 45, arrow: "‚Æï" },
          { from: 68, to: 95, arrow: "‚Æï" },
          { from: 110, to: 138, arrow: "‚Æï" },
        ];

        teleportPositions.forEach((tp) => {
          if (tp.from < path.length && tp.to < path.length) {
            path[tp.from].color = "purple";
            path[tp.from].arrow = tp.arrow;
            path[tp.from].teleportTo = tp.to;
            shortcuts.push({ from: tp.from, to: tp.to });
          }
        });

        return path;
      }

      const shortcuts = [];
      const boardPath = generateBoardPath();

      // Game state
      let gamePlayers = [];
      let currentPlayer = 0;
      let playerPositions = [];
      let playerPieces = [];
      let currentQuestion = null;
      let currentDifficulty = null;
      let usedProblems = { white: [], green: [], yellow: [], red: [] };
      let bonusRollInTurn = false;
      let questionTimer = null;
      let questionTimeLeft = 0;

      // Online mode variables
      let isOnlineMode = false;
      let isHost = false;
      let peer = null;
      let connections = [];
      let onlineRoomId = null;
      let onlinePlayers = [];

      // Mobile player variables
      let myPeer = null;
      let hostConnection = null;
      let myPlayerName = '';
      let myPlayerColor = '';
      let allPlayers = [];
      let currentTurn = 0;
      let mobileQuestionTimer = null;
      let isJoining = false;
      let mobileInitialized = false;
      let takenColors = [];
      let lastPlayersListHTML = '';
      let lastTurnMessageHTML = '';

      // =====  LOCAL MODE FUNCTIONS =====
      
      let playerCount = 0;
      const usedColors = new Set();
      const usedNames = new Set();

      function addPlayer() {
        if (playerCount >= 4) return;

        playerCount++;
        const container = document.getElementById("playersContainer");
        const playerSetup = document.createElement("div");
        playerSetup.className = "player-setup";
        playerSetup.id = `player${playerCount}Setup`;

        const colors = [
          { name: "blue", hex: "#4dabf7" },
          { name: "red", hex: "#ff6b6b" },
          { name: "green", hex: "#51cf66" },
          { name: "yellow", hex: "#ffd43b" },
          { name: "purple", hex: "#9b59b6" },
          { name: "orange", hex: "#ff922b" },
          { name: "pink", hex: "#ff6ba9" },
          { name: "cyan", hex: "#22b8cf" },
        ];

        playerSetup.innerHTML = `
          <h3>Gracz ${playerCount}</h3>
          <input type="text" id="player${playerCount}Name" placeholder="Wpisz imiƒô" oninput="validateNames()" />
          <div class="error-message" id="player${playerCount}Error">To imiƒô jest ju≈º zajƒôte!</div>
          <div class="color-selector" id="colors${playerCount}">
            ${colors.map(c => `<div class="color-option" style="background: ${c.hex};" data-color="${c.name}" onclick="selectColor(${playerCount}, '${c.name}')"></div>`).join('')}
          </div>
        `;

        container.appendChild(playerSetup);
        colors[0] && selectColor(playerCount, colors[0].name);

        if (playerCount >= 4) {
          document.getElementById("addPlayerBtn").disabled = true;
        }

        updateStartButton();
        updateColorOptions();
      }

      function selectColor(playerNum, color) {
        if (usedColors.has(color)) return;

        const previousColor = gamePlayers.find(p => p.num === playerNum)?.color;
        if (previousColor) {
          usedColors.delete(previousColor);
        }

        usedColors.add(color);
        gamePlayers = gamePlayers.filter(p => p.num !== playerNum);

        const name = document.getElementById(`player${playerNum}Name`).value || `Gracz ${playerNum}`;
        gamePlayers.push({ num: playerNum, name: name, color: color });

        updateColorOptions();
        updateStartButton();
      }

      function updateColorOptions() {
        for (let i = 1; i <= playerCount; i++) {
          const setup = document.getElementById(`player${i}Setup`);
          if (!setup) continue;

          const options = setup.querySelectorAll(".color-option");
          options.forEach((option) => {
            const color = option.dataset.color;
            const isSelected = gamePlayers.find(p => p.num === i)?.color === color;
            const isUsed = usedColors.has(color) && !isSelected;

            option.classList.toggle("selected", isSelected);
            option.classList.toggle("disabled", isUsed);
          });
        }
      }

      function validateNames() {
        usedNames.clear();
        let allValid = true;

        for (let i = 1; i <= playerCount; i++) {
          const input = document.getElementById(`player${i}Name`);
          const error = document.getElementById(`player${i}Error`);
          if (!input) continue;

          const name = input.value.trim().toLowerCase();

          if (name && usedNames.has(name)) {
            input.classList.add("error");
            error.classList.add("show");
            allValid = false;
          } else {
            input.classList.remove("error");
            error.classList.remove("show");
            if (name) {
              usedNames.add(name);
            }
          }
        }

        return allValid;
      }

      function updateStartButton() {
        const namesValid = validateNames();

        const validPlayers = gamePlayers.filter((p) => {
          const name = document.getElementById(`player${p.num}Name`)?.value;
          return name && name.trim() !== "" && p.color;
        });

        document.getElementById("startGameBtn").disabled = validPlayers.length < 2 || !namesValid;
      }

      document.addEventListener("input", (e) => {
        if (e.target.matches('[id^="player"][id$="Name"]')) {
          const playerNum = parseInt(e.target.id.match(/\d+/)[0]);
          const existingPlayer = gamePlayers.find((p) => p.num === playerNum);
          if (existingPlayer) {
            existingPlayer.name = e.target.value || `Gracz ${playerNum}`;
          }
          updateStartButton();
        }
      });

      function startGame() {
        if (!validateNames()) {
          alert("Ka≈ºdy gracz musi mieƒá unikalnƒÖ nazwƒô!");
          return;
        }

        gamePlayers = gamePlayers.filter((p) => {
          const name = document.getElementById(`player${p.num}Name`)?.value;
          return name && name.trim() !== "" && p.color;
        });

        if (gamePlayers.length < 2) {
          alert("Potrzebujesz co najmniej 2 graczy!");
          return;
        }

        gamePlayers.sort((a, b) => a.num - b.num);
        playerPositions = new Array(gamePlayers.length).fill(0);

        document.getElementById("setupScreen").style.display = "none";
        document.getElementById("gameScreen").style.display = "block";
        document.getElementById("localControls").style.display = "block";

        initBoard();
      }

      function initBoard() {
        const board = document.getElementById("board");
        
        // Clear previous content except markers and instructions
        const markers = board.querySelectorAll('.start-marker, .finish-marker, .instructions-toggle, .instructions-panel');
        board.innerHTML = '';
        markers.forEach(m => board.appendChild(m));

        const svg = document.createElementNS("http://www.w3.org/2000/svg", "svg");
        svg.style.position = "absolute";
        svg.style.top = "0";
        svg.style.left = "0";
        svg.style.width = "100%";
        svg.style.height = "100%";
        svg.style.pointerEvents = "none";
        svg.style.zIndex = "5";
        board.appendChild(svg);

        for (let i = 0; i < boardPath.length - 1; i++) {
          const current = boardPath[i];
          const next = boardPath[i + 1];

          const line = document.createElementNS("http://www.w3.org/2000/svg", "line");
          line.setAttribute("x1", current.x + 20);
          line.setAttribute("y1", current.y + 20);
          line.setAttribute("x2", next.x + 20);
          line.setAttribute("y2", next.y + 20);
          line.setAttribute("class", "path-line");
          svg.appendChild(line);
        }

        shortcuts.forEach((shortcut) => {
          const fromSpace = boardPath[shortcut.from];
          const toSpace = boardPath[shortcut.to];

          const line = document.createElementNS("http://www.w3.org/2000/svg", "line");
          line.setAttribute("x1", fromSpace.x + 20);
          line.setAttribute("y1", fromSpace.y + 20);
          line.setAttribute("x2", toSpace.x + 20);
          line.setAttribute("y2", toSpace.y + 20);
          line.setAttribute("class", "teleport-line");
          svg.appendChild(line);
        });

        boardPath.forEach((space, index) => {
          const spaceElement = document.createElement("div");
          spaceElement.className = `space ${space.color}`;
          spaceElement.style.left = space.x + "px";
          spaceElement.style.top = space.y + "px";

          if (index === 0) {
            spaceElement.textContent = "üöÄ";
          } else if (index === boardPath.length - 1) {
            spaceElement.textContent = "üèÅ";
          } else if (space.arrow) {
            spaceElement.textContent = space.arrow;
          }

          board.appendChild(spaceElement);
        });

        playerPieces = [];
        gamePlayers.forEach((player, index) => {
          const piece = document.createElement("div");
          piece.className = "player-piece";
          piece.style.background = getPlayerColor(player.color);
          piece.id = `playerPiece${index}`;
          board.appendChild(piece);
          playerPieces.push(piece);
          updatePlayerPosition(index);
        });

        updateCurrentPlayerDisplay();
      }

      function getPlayerColor(color) {
        const colors = {
          blue: "#4dabf7",
          red: "#ff6b6b",
          green: "#51cf66",
          yellow: "#ffd43b",
          purple: "#9b59b6",
          orange: "#ff922b",
          pink: "#ff6ba9",
          cyan: "#22b8cf",
        };
        return colors[color] || "#4dabf7";
      }

      function updatePlayerPosition(playerIndex) {
        const position = playerPositions[playerIndex];
        const piece = playerPieces[playerIndex];
        if (!piece) return;

        if (position >= boardPath.length) {
          const space = boardPath[boardPath.length - 1];
          piece.style.left = space.x + 5 + "px";
          piece.style.top = space.y + 5 + "px";
          return;
        }

        if (position < 0) {
          playerPositions[playerIndex] = 0;
          updatePlayerPosition(playerIndex);
          return;
        }

        const space = boardPath[position];
        const uniqueOffset = playerIndex * 6;
        piece.style.left = space.x + 5 + uniqueOffset + "px";
        piece.style.top = space.y + 5 + uniqueOffset + "px";
      }

      function playJumpSound() {
        const audioContext = new (window.AudioContext || window.webkitAudioContext)();
        const oscillator = audioContext.createOscillator();
        const gainNode = audioContext.createGain();

        oscillator.connect(gainNode);
        gainNode.connect(audioContext.destination);

        oscillator.frequency.value = 150;
        oscillator.type = "triangle";

        gainNode.gain.setValueAtTime(0.4, audioContext.currentTime);
        gainNode.gain.exponentialRampToValueAtTime(0.01, audioContext.currentTime + 0.08);

        oscillator.start(audioContext.currentTime);
        oscillator.stop(audioContext.currentTime + 0.08);
      }

      function animatePlayerMovement(playerIndex, fromPosition, toPosition, callback) {
        if (fromPosition === toPosition) {
          if (callback) callback();
          return;
        }

        const direction = toPosition > fromPosition ? 1 : -1;
        let currentPos = fromPosition;
        const piece = playerPieces[playerIndex];

        function moveOneStep() {
          if (
            (direction > 0 && currentPos >= toPosition) ||
            (direction < 0 && currentPos <= toPosition)
          ) {
            playerPositions[playerIndex] = toPosition;
            updatePlayerPosition(playerIndex);
            if (callback) callback();
            return;
          }

          currentPos += direction;
          playerPositions[playerIndex] = currentPos;
          updatePlayerPosition(playerIndex);
          playJumpSound();

          if (piece) {
            piece.style.transform = "scale(1.3)";
            setTimeout(() => {
              piece.style.transform = "scale(1)";
            }, 100);
          }

          setTimeout(moveOneStep, 200);
        }

        moveOneStep();
      }

      function updateCurrentPlayerDisplay() {
        const player = gamePlayers[currentPlayer];
        const display = document.getElementById("currentPlayer");
        if (display) {
          display.innerHTML = `Tura: <span style="color: ${getPlayerColor(player.color)}; text-shadow: 0 0 15px ${getPlayerColor(player.color)};">${player.name}</span>`;
        }
      }

      let diceRolling = false;

      function rollDice() {
        if (diceRolling) return;

        diceRolling = true;
        const rollBtn = document.getElementById("rollDiceBtn");
        if (rollBtn) rollBtn.disabled = true;

        const playerIndex = currentPlayer;
        const result = Math.floor(Math.random() * 6) + 1;
        playDiceSound();
        showDiceAnimation(result);

        const diceResultEl = document.getElementById("diceResult");
        if (diceResultEl) {
          diceResultEl.textContent = `Wyrzucono: ${result}`;
        }

        setTimeout(() => {
          const oldPosition = playerPositions[playerIndex];
          const newPosition = Math.min(oldPosition + result, boardPath.length);

          animatePlayerMovement(playerIndex, oldPosition, newPosition, () => {
            diceRolling = false;
            if (rollBtn) rollBtn.disabled = false;

            if (playerPositions[playerIndex] >= boardPath.length) {
              setTimeout(() => {
                showNotification(`üéâüèÜ ${gamePlayers[playerIndex].name} WYGRYWA! üèÜüéâ`, "success");
                setTimeout(() => location.reload(), 3000);
              }, 500);
              return;
            }

            setTimeout(() => {
              checkSpaceAndAskQuestion();
            }, 300);
          });
        }, 1000);
      }

      function playDiceSound() {
        const audioContext = new (window.AudioContext || window.webkitAudioContext)();

        for (let i = 0; i < 8; i++) {
          setTimeout(() => {
            const oscillator = audioContext.createOscillator();
            const gainNode = audioContext.createGain();

            oscillator.connect(gainNode);
            gainNode.connect(audioContext.destination);

            oscillator.frequency.value = 100 + Math.random() * 200;
            oscillator.type = "square";

            gainNode.gain.setValueAtTime(0.3, audioContext.currentTime);
            gainNode.gain.exponentialRampToValueAtTime(0.01, audioContext.currentTime + 0.05);

            oscillator.start(audioContext.currentTime);
            oscillator.stop(audioContext.currentTime + 0.05);
          }, i * 100);
        }
      }

      function showDiceAnimation(result) {
        const diceEl = document.getElementById("diceAnimation");
        const numberEl = document.getElementById("diceNumber");

        diceEl.style.display = "block";

        let count = 0;
        const interval = setInterval(() => {
          numberEl.textContent = Math.floor(Math.random() * 6) + 1;
          count++;
          if (count > 10) {
            clearInterval(interval);
            numberEl.textContent = result;
          }
        }, 80);

        setTimeout(() => {
          diceEl.style.display = "none";
        }, 1000);
      }

      function checkSpaceAndAskQuestion() {
        const playerIndex = currentPlayer;

        if (
          playerPositions[playerIndex] > 0 &&
          playerPositions[playerIndex] < boardPath.length
        ) {
          const spaceColor = boardPath[playerPositions[playerIndex]].color;

          if (
            spaceColor === "purple" ||
            spaceColor === "green" ||
            spaceColor === "yellow" ||
            spaceColor === "red" ||
            spaceColor === "white"
          ) {
            askQuestion(spaceColor);
          } else {
            nextPlayer();
          }
        } else {
          nextPlayer();
        }
      }

      function drawCard(difficulty) {
        let deckId = "";
        if (difficulty === "white") {
          deckId = "whiteDeck";
        } else if (difficulty === "green") {
          deckId = "greenDeck";
        } else if (difficulty === "yellow") {
          deckId = "yellowDeck";
        } else if (difficulty === "red" || difficulty === "purple") {
          deckId = "redDeck";
        }

        if (!deckId) return;

        const deck = document.getElementById(deckId);
        if (!deck) return;
        
        const card = deck.querySelector(".deck-card");
        if (!card) return;

        const animCard = card.cloneNode(true);
        animCard.classList.add("card-drawing");
        deck.appendChild(animCard);

        setTimeout(() => {
          animCard.remove();
        }, 1200);
      }

      function askQuestion(difficulty) {
        currentDifficulty = difficulty;

        drawCard(difficulty);

        setTimeout(() => {
          const problemDifficulty = difficulty === "purple" ? "red" : difficulty;
          const problems = mathProblems[problemDifficulty];

          let problem;
          let attempts = 0;
          do {
            problem = problems[Math.floor(Math.random() * problems.length)];
            attempts++;
          } while (
            usedProblems[problemDifficulty].includes(problem.q) &&
            attempts < 50
          );

          if (attempts >= 50) {
            usedProblems[problemDifficulty] = [];
            problem = problems[Math.floor(Math.random() * problems.length)];
          }

          usedProblems[problemDifficulty].push(problem.q);
          currentQuestion = problem;

          const levelNames = {
            white: "DODAWANIE/ODEJMOWANIE ‚ö™",
            green: "≈ÅATWE üü¢",
            yellow: "≈öREDNIE üü°",
            red: "TRUDNE üî¥",
            purple: "TELEPORT üü£ - TRUDNE PYTANIE!",
          };

          document.getElementById("questionText").textContent = `${levelNames[difficulty]}: ${problem.q} = ?`;
          document.getElementById("answerInput").value = "";
          document.getElementById("correctAnswer").textContent = `Poprawna odpowied≈∫: ${problem.a}`;
          document.getElementById("correctAnswer").style.display = "none";

          document.getElementById("questionModal").style.display = "flex";
          document.getElementById("answerInput").focus();

          startQuestionTimer();
        }, 800);
      }

      let checkingAnswer = false;

      function checkAnswer() {
        if (checkingAnswer) return;

        checkingAnswer = true;
        const checkBtn = document.getElementById("checkAnswerBtn");
        if (checkBtn) checkBtn.disabled = true;

        const playerIndex = currentPlayer;

        stopQuestionTimer();

        const userAnswer = parseInt(document.getElementById("answerInput").value);
        const correctAnswerEl = document.getElementById("correctAnswer");
        correctAnswerEl.style.display = "block";

        if (userAnswer === currentQuestion.a) {
          let movement = 0;
          let message = "";
          let giveBonus = false;
          let teleport = false;
          let teleportTo = null;

          if (currentDifficulty === "white") {
            movement = 0;
            message = "‚úì DOBRZE!\nZostajesz w miejscu!";
          } else if (currentDifficulty === "purple") {
            const currentSpace = boardPath[playerPositions[playerIndex]];
            if (currentSpace.teleportTo !== undefined) {
              teleport = true;
              teleportTo = currentSpace.teleportTo;
              message = "‚úì DOBRZE!\nüöÄ TELEPORTACJA!";
            }
          } else if (currentDifficulty === "green") {
            movement = 1;
            message = "‚úì DOBRZE! +1 pole";
          } else if (currentDifficulty === "yellow") {
            movement = 2;
            if (!bonusRollInTurn) {
              message = "‚úì DOBRZE! +2 pola\nüé≤ BONUS: Rzuƒá jeszcze raz!";
              giveBonus = true;
            } else {
              message = "‚úì DOBRZE! +2 pola\n(Maksymalnie 2 rzuty w turze)";
            }
          } else if (currentDifficulty === "red") {
            movement = 3;
            if (!bonusRollInTurn) {
              message = "‚úì DOBRZE! +3 pola\nüé≤ BONUS: Rzuƒá jeszcze raz!";
              giveBonus = true;
            } else {
              message = "‚úì DOBRZE! +3 pola\n(Maksymalnie 2 rzuty w turze)";
            }
          }

          showNotification(message, "success");

          setTimeout(() => {
            document.getElementById("questionModal").style.display = "none";
            correctAnswerEl.style.display = "none";

            const oldPosition = playerPositions[playerIndex];
            let newPosition;

            if (teleport) {
              newPosition = Math.min(teleportTo, boardPath.length);
            } else {
              newPosition = Math.min(oldPosition + movement, boardPath.length);
            }

            animatePlayerMovement(playerIndex, oldPosition, newPosition, () => {
              if (playerPositions[playerIndex] >= boardPath.length) {
                setTimeout(() => {
                  showNotification(`üéâüèÜ ${gamePlayers[playerIndex].name} WYGRYWA! üèÜüéâ`, "success");
                  setTimeout(() => location.reload(), 3000);
                }, 500);
                return;
              }

              checkingAnswer = false;
              if (checkBtn) checkBtn.disabled = false;

              if (giveBonus) {
                bonusRollInTurn = true;
                setTimeout(() => {
                  showNotification("üé≤ Twoja kolej - rzuƒá jeszcze raz!", "success");
                }, 500);
              } else {
                bonusRollInTurn = false;
                nextPlayer();
              }
            });
          }, 2000);
        } else {
          let movement = 0;
          let message = "";

          if (currentDifficulty === "white") {
            movement = -4;
            message = `‚úó ≈πLE! Poprawna: ${currentQuestion.a}\nCofasz siƒô 4 pola!`;
          } else if (currentDifficulty === "purple") {
            movement = 0;
            message = `‚úó ≈πLE! Poprawna: ${currentQuestion.a}\nZostajesz na miejscu!`;
          } else if (currentDifficulty === "green") {
            movement = -3;
            message = `‚úó ≈πLE! Poprawna: ${currentQuestion.a}\nCofasz siƒô 3 pola!`;
          } else if (currentDifficulty === "yellow") {
            movement = -2;
            message = `‚úó ≈πLE! Poprawna: ${currentQuestion.a}\nCofasz siƒô 2 pola!`;
          } else if (currentDifficulty === "red") {
            movement = -1;
            message = `‚úó ≈πLE! Poprawna: ${currentQuestion.a}\nCofasz siƒô 1 pole!`;
          }

          showNotification(message, "error");

          setTimeout(() => {
            document.getElementById("questionModal").style.display = "none";
            correctAnswerEl.style.display = "none";

            const oldPosition = playerPositions[playerIndex];
            const newPosition = Math.max(0, oldPosition + movement);

            animatePlayerMovement(playerIndex, oldPosition, newPosition, () => {
              bonusRollInTurn = false;
              nextPlayer();
            });
            
            checkingAnswer = false;
            if (checkBtn) checkBtn.disabled = false;
          }, 2000);
        }
      }

      function showNotification(message, type) {
        const notification = document.getElementById("tempNotification");
        notification.textContent = message;
        notification.className = `temp-notification ${type}`;
        notification.style.display = "block";

        setTimeout(() => {
          notification.style.display = "none";
        }, 2000);
      }

      document.addEventListener("keypress", (e) => {
        if (
          e.key === "Enter" &&
          document.getElementById("questionModal").style.display === "flex"
        ) {
          checkAnswer();
        }
      });

      function getQuestionTimeLimit(difficulty) {
        const limits = {
          white: 30,
          green: 30,
          yellow: 60,
          red: 90,
          purple: 90,
        };
        return limits[difficulty] || 60;
      }

      function startQuestionTimer() {
        if (questionTimer) {
          clearInterval(questionTimer);
        }

        const timeLimit = getQuestionTimeLimit(currentDifficulty);
        questionTimeLeft = timeLimit;

        updateTimerDisplay();

        questionTimer = setInterval(() => {
          questionTimeLeft--;
          updateTimerDisplay();

          if (questionTimeLeft <= 0) {
            clearInterval(questionTimer);
            handleTimeOut();
          }
        }, 1000);
      }

      function updateTimerDisplay() {
        const timerEl = document.getElementById("questionTimer");
        if (!timerEl) return;

        const minutes = Math.floor(questionTimeLeft / 60);
        const seconds = questionTimeLeft % 60;
        timerEl.textContent = `${minutes}:${seconds.toString().padStart(2, "0")}`;

        timerEl.classList.remove("warning", "danger");

        const timeLimit = getQuestionTimeLimit(currentDifficulty);
        if (questionTimeLeft <= 10) {
          timerEl.classList.add("danger");
        } else if (questionTimeLeft <= timeLimit / 3) {
          timerEl.classList.add("warning");
        }
      }

      function stopQuestionTimer() {
        if (questionTimer) {
          clearInterval(questionTimer);
          questionTimer = null;
        }
      }

      function handleTimeOut() {
        showNotification(`‚è∞ CZAS MINƒÑ≈Å!`, "error");

        setTimeout(() => {
          document.getElementById("answerInput").value = "999999";
          checkAnswer();
        }, 1000);
      }

      function nextPlayer() {
        bonusRollInTurn = false;
        currentPlayer = (currentPlayer + 1) % gamePlayers.length;
        updateCurrentPlayerDisplay();
      }

      function toggleInstructions() {
        const panel = document.getElementById("instructionsPanel");
        panel.classList.toggle("open");
      }

      // ===== ONLINE MODE - HOST =====

      function generateRoomId() {
        return 'room_' + Math.random().toString(36).substr(2, 9);
      }

      function openOnlineMode() {
        if (typeof Peer === 'undefined') {
          alert('Biblioteka PeerJS nie zosta≈Ça za≈Çadowana. Sprawd≈∫ po≈ÇƒÖczenie internetowe i od≈õwie≈º stronƒô.');
          return;
        }

        isOnlineMode = true;
        isHost = true;
        
        onlineRoomId = generateRoomId();
        
        try {
          peer = new Peer(onlineRoomId);
        } catch (error) {
          alert('Nie mo≈ºna uruchomiƒá trybu online: ' + error.message);
          return;
        }

        peer.on('open', function(id) {
          console.log('Room ID:', id);
          
          document.getElementById('onlineStatusText').textContent = 'Zeskanuj kod QR telefonem!';
          
          const currentUrl = window.location.href.split('?')[0];
          const playerUrl = currentUrl + '?room=' + onlineRoomId;
          
          document.getElementById('qrcode').innerHTML = '';
          
          if (typeof QRCode === 'undefined') {
            document.getElementById('qrcode').innerHTML = '<div style="color: #333; padding: 20px; text-align: left;"><strong>Kod pokoju:</strong><br>' + onlineRoomId + '<br><br><strong>Link dla graczy:</strong><br><small>' + playerUrl + '</small></div>';
          } else {
            try {
              new QRCode(document.getElementById('qrcode'), {
                text: playerUrl,
                width: 256,
                height: 256
              });
            } catch (error) {
              document.getElementById('qrcode').innerHTML = '<div style="color: #333; padding: 20px;">Link: ' + playerUrl + '</div>';
            }
          }

          document.getElementById('onlineLobby').style.display = 'flex';
        });

        peer.on('connection', function(conn) {
          console.log('Player connected:', conn.peer);
          connections.push(conn);
          
          // Send current taken colors immediately
          setTimeout(() => {
            if (conn.open) {
              const takenColors = onlinePlayers.map(p => p.color);
              conn.send({
                type: 'takenColors',
                colors: takenColors
              });
            }
          }, 100);
          
          conn.on('data', function(data) {
            handlePlayerMessage(conn, data);
          });

          conn.on('close', function() {
            connections = connections.filter(c => c !== conn);
            onlinePlayers = onlinePlayers.filter(p => p.conn !== conn);
            updatePlayersWaitingList();
            broadcastTakenColors();
          });
        });

        peer.on('error', function(err) {
          console.error('Peer error:', err);
          if (err.type === 'unavailable-id') {
            alert('Pok√≥j jest ju≈º zajƒôty. Spr√≥buj ponownie.');
            closeOnlineMode();
          } else if (err.type === 'network') {
            alert('B≈ÇƒÖd sieci. Sprawd≈∫ po≈ÇƒÖczenie internetowe.');
          } else {
            alert('B≈ÇƒÖd po≈ÇƒÖczenia: ' + err.type);
          }
        });
      }

      function closeOnlineMode() {
        if (peer) {
          peer.destroy();
        }
        connections = [];
        onlinePlayers = [];
        isOnlineMode = false;
        isHost = false;
        document.getElementById('onlineLobby').style.display = 'none';
        document.getElementById('qrcode').innerHTML = '';
      }

      function handlePlayerMessage(conn, data) {
        console.log('Received from player:', data);

        if (data.type === 'join') {
          // Check if player already exists
          const existingPlayer = onlinePlayers.find(p => p.conn === conn);
          if (!existingPlayer) {
            // Check if color is already taken
            const colorTaken = onlinePlayers.some(p => p.color === data.color);
            if (colorTaken) {
              conn.send({ type: 'error', message: 'Ten kolor jest ju≈º zajƒôty!' });
              return;
            }

            onlinePlayers.push({
              conn: conn,
              name: data.name,
              color: data.color,
              id: conn.peer
            });
            updatePlayersWaitingList();
            
            // Send success to this player
            conn.send({ type: 'joined', success: true });
            
            // Broadcast taken colors to ALL players
            broadcastTakenColors();
          }
        } else if (data.type === 'roll') {
          if (isCurrentPlayerTurn(conn)) {
            rollDiceOnline();
          }
        } else if (data.type === 'answer') {
          if (isCurrentPlayerTurn(conn)) {
            submitAnswerOnline(data.answer);
          }
        }
      }
      
      function broadcastTakenColors() {
        const takenColors = onlinePlayers.map(p => p.color);
        connections.forEach(conn => {
          if (conn.open) {
            conn.send({
              type: 'takenColors',
              colors: takenColors
            });
          }
        });
      }

      function isCurrentPlayerTurn(conn) {
        if (!gamePlayers.length || !isOnlineMode) return false;
        const currentPlayerConn = gamePlayers[currentPlayer].conn;
        return currentPlayerConn === conn;
      }

      function updatePlayersWaitingList() {
        const list = document.getElementById('playersWaitingList');
        if (onlinePlayers.length === 0) {
          list.innerHTML = '<p style="color: #999;">Czekam na graczy...</p>';
        } else {
          list.innerHTML = onlinePlayers.map(p => `
            <div class="player-item">
              <div class="player-color-dot" style="background: ${getPlayerColor(p.color)};"></div>
              <strong>${p.name}</strong>
            </div>
          `).join('');
        }

        const startBtn = document.getElementById('startOnlineBtn');
        if (onlinePlayers.length >= 2 && onlinePlayers.length <= 4) {
          startBtn.disabled = false;
          startBtn.textContent = `üéÆ START GRY (${onlinePlayers.length} ${onlinePlayers.length === 1 ? 'gracz' : onlinePlayers.length < 5 ? 'graczy' : 'graczy'})`;
        } else if (onlinePlayers.length === 1) {
          startBtn.disabled = true;
          startBtn.textContent = `Czekam na wiƒôcej graczy... (1/2)`;
        } else {
          startBtn.disabled = true;
          startBtn.textContent = `üéÆ START GRY (min. 2 graczy)`;
        }
      }

      function startOnlineGame() {
        if (onlinePlayers.length < 2 || onlinePlayers.length > 4) {
          alert('Potrzeba 2-4 graczy!');
          return;
        }

        gamePlayers = onlinePlayers.map((p, idx) => ({
          num: idx + 1,
          name: p.name,
          color: p.color,
          conn: p.conn
        }));

        playerPositions = new Array(gamePlayers.length).fill(0);

        document.getElementById('onlineLobby').style.display = 'none';
        document.getElementById('setupScreen').style.display = 'none';
        document.getElementById('gameScreen').style.display = 'block';
        document.getElementById('localControls').style.display = 'none';

        initBoard();

        broadcastToPlayers({
          type: 'gameStart',
          players: gamePlayers.map(p => ({ name: p.name, color: p.color })),
          currentPlayer: 0
        });

        notifyPlayerTurn(0);
      }

      function notifyPlayerTurn(playerIndex) {
        currentPlayer = playerIndex;
        const player = gamePlayers[playerIndex];
        
        broadcastToPlayers({
          type: 'turnUpdate',
          currentPlayer: playerIndex
        });

        if (player.conn) {
          player.conn.send({
            type: 'yourTurn',
            canRoll: true
          });
        }
      }

      function rollDiceOnline() {
        const playerIndex = currentPlayer;
        const result = Math.floor(Math.random() * 6) + 1;

        broadcastToPlayers({
          type: 'diceRolled',
          player: playerIndex,
          result: result
        });

        playDiceSound();
        showDiceAnimation(result);

        setTimeout(() => {
          const oldPosition = playerPositions[playerIndex];
          const newPosition = Math.min(oldPosition + result, boardPath.length);

          animatePlayerMovement(playerIndex, oldPosition, newPosition, () => {
            broadcastToPlayers({
              type: 'positionUpdate',
              player: playerIndex,
              position: playerPositions[playerIndex]
            });

            if (playerPositions[playerIndex] >= boardPath.length) {
              handleWinnerOnline(playerIndex);
              return;
            }

            setTimeout(() => {
              checkSpaceAndAskQuestionOnline(playerIndex);
            }, 300);
          });
        }, 1000);
      }

      function checkSpaceAndAskQuestionOnline(playerIndex) {
        if (
          playerPositions[playerIndex] > 0 &&
          playerPositions[playerIndex] < boardPath.length
        ) {
          const spaceColor = boardPath[playerPositions[playerIndex]].color;

          if (
            spaceColor === "white" ||
            spaceColor === "green" ||
            spaceColor === "yellow" ||
            spaceColor === "red" ||
            spaceColor === "purple"
          ) {
            askQuestionOnline(spaceColor, playerIndex);
          } else {
            nextPlayerOnline();
          }
        } else {
          nextPlayerOnline();
        }
      }

      function askQuestionOnline(difficulty, playerIndex) {
        currentDifficulty = difficulty;
        
        drawCard(difficulty);
        
        const problemDifficulty = difficulty === "purple" ? "red" : difficulty;
        const problems = mathProblems[problemDifficulty];
        
        let problem;
        let attempts = 0;
        do {
          problem = problems[Math.floor(Math.random() * problems.length)];
          attempts++;
        } while (
          usedProblems[problemDifficulty].includes(problem.q) &&
          attempts < 50
        );

        if (attempts >= 50) {
          usedProblems[problemDifficulty] = [];
          problem = problems[Math.floor(Math.random() * problems.length)];
        }

        usedProblems[problemDifficulty].push(problem.q);
        currentQuestion = problem;

        const player = gamePlayers[playerIndex];
        if (player.conn) {
          player.conn.send({
            type: 'question',
            difficulty: difficulty,
            question: problem.q,
            timeLimit: getQuestionTimeLimit(difficulty)
          });
        }
      }

      function submitAnswerOnline(answer) {
        const playerIndex = currentPlayer;
        const userAnswer = parseInt(answer);

        if (userAnswer === currentQuestion.a) {
          handleCorrectAnswerOnline(playerIndex);
        } else {
          handleWrongAnswerOnline(playerIndex);
        }
      }

      function handleCorrectAnswerOnline(playerIndex) {
        let movement = 0;
        let giveBonus = false;
        let teleport = false;
        let teleportTo = null;

        if (currentDifficulty === "white") {
          movement = 0;
        } else if (currentDifficulty === "purple") {
          const currentSpace = boardPath[playerPositions[playerIndex]];
          if (currentSpace.teleportTo !== undefined) {
            teleport = true;
            teleportTo = currentSpace.teleportTo;
          }
        } else if (currentDifficulty === "green") {
          movement = 1;
        } else if (currentDifficulty === "yellow") {
          movement = 2;
          if (!bonusRollInTurn) giveBonus = true;
        } else if (currentDifficulty === "red") {
          movement = 3;
          if (!bonusRollInTurn) giveBonus = true;
        }

        const oldPosition = playerPositions[playerIndex];
        let newPosition;

        if (teleport) {
          newPosition = Math.min(teleportTo, boardPath.length);
        } else {
          newPosition = Math.min(oldPosition + movement, boardPath.length);
        }

        animatePlayerMovement(playerIndex, oldPosition, newPosition, () => {
          broadcastToPlayers({
            type: 'positionUpdate',
            player: playerIndex,
            position: playerPositions[playerIndex]
          });

          if (playerPositions[playerIndex] >= boardPath.length) {
            handleWinnerOnline(playerIndex);
            return;
          }

          if (giveBonus) {
            bonusRollInTurn = true;
            notifyPlayerTurn(playerIndex);
          } else {
            bonusRollInTurn = false;
            nextPlayerOnline();
          }
        });
      }

      function handleWrongAnswerOnline(playerIndex) {
        let movement = 0;

        if (currentDifficulty === "white") {
          movement = -4;
        } else if (currentDifficulty === "purple") {
          movement = 0;
        } else if (currentDifficulty === "green") {
          movement = -3;
        } else if (currentDifficulty === "yellow") {
          movement = -2;
        } else if (currentDifficulty === "red") {
          movement = -1;
        }

        const oldPosition = playerPositions[playerIndex];
        const newPosition = Math.max(0, oldPosition + movement);

        animatePlayerMovement(playerIndex, oldPosition, newPosition, () => {
          broadcastToPlayers({
            type: 'positionUpdate',
            player: playerIndex,
            position: playerPositions[playerIndex]
          });

          bonusRollInTurn = false;
          nextPlayerOnline();
        });
      }

      function nextPlayerOnline() {
        bonusRollInTurn = false;
        currentPlayer = (currentPlayer + 1) % gamePlayers.length;
        notifyPlayerTurn(currentPlayer);
      }

      function handleWinnerOnline(playerIndex) {
        const player = gamePlayers[playerIndex];
        
        broadcastToPlayers({
          type: 'gameOver',
          winner: player.name,
          winnerColor: player.color
        });

        setTimeout(() => {
          showNotification(`üéâüèÜ ${player.name} WYGRYWA! üèÜüéâ`, "success");
          setTimeout(() => {
            if (confirm(`${player.name} wygra≈Ç! Zagraƒá jeszcze raz?`)) {
              location.reload();
            }
          }, 3000);
        }, 500);
      }

      function broadcastToPlayers(message) {
        connections.forEach(conn => {
          if (conn.open) {
            conn.send(message);
          }
        });
      }

      // ===== MOBILE PLAYER MODE =====

      function initMobilePlayer(room) {
        if (mobileInitialized) {
          console.log('Already initialized');
          return;
        }
        mobileInitialized = true;
        console.log('Init mobile player for room:', room);
        
        if (typeof Peer === 'undefined') {
          console.error('PeerJS not loaded');
          showMobileError('B≈ÇƒÖd ≈Çadowania bibliotek. Od≈õwie≈º stronƒô.');
          return;
        }

        try {
          myPeer = new Peer();
        } catch (error) {
          console.error('Peer init error:', error);
          showMobileError('B≈ÇƒÖd inicjalizacji: ' + error.message);
          return;
        }

        myPeer.on('open', function(id) {
          console.log('Peer ready:', id);
          const loadingMsg = document.getElementById('mobileLoadingMsg');
          if (loadingMsg) loadingMsg.style.display = 'none';
        });

        myPeer.on('error', function(err) {
          console.error('Peer error:', err);
          showMobileError('B≈ÇƒÖd po≈ÇƒÖczenia: ' + err.type);
        });

        // Prevent form submission on all inputs
        document.querySelectorAll('.mobile-player-screen input').forEach(input => {
          input.addEventListener('keydown', function(e) {
            if (e.key === 'Enter') {
              e.preventDefault();
            }
          });
        });

        // Setup color buttons - ONCE
        const colorBtns = document.querySelectorAll('.mobile-color-option');
        colorBtns.forEach(btn => {
          btn.addEventListener('click', function(e) {
            e.preventDefault();
            const color = this.dataset.color;
            if (takenColors.includes(color)) return;
            
            colorBtns.forEach(b => b.classList.remove('selected'));
            this.classList.add('selected');
            myPlayerColor = color;
            checkCanJoin();
          });
        });
        
        // Select first color by default
        if (colorBtns[0]) {
          colorBtns[0].classList.add('selected');
          myPlayerColor = colorBtns[0].dataset.color;
        }
        
        // Setup name input - ONCE
        const nameInput = document.getElementById('mobilePlayerName');
        nameInput.addEventListener('input', function() {
          checkCanJoin();
        });
        
        // Setup join button - ONCE
        const joinBtn = document.getElementById('mobileJoinBtn');
        joinBtn.addEventListener('click', function(e) {
          e.preventDefault();
          joinMobileGame();
        });
        
        // Setup roll button - ONCE
        const rollBtn = document.getElementById('mobileRollBtn');
        rollBtn.addEventListener('click', function(e) {
          e.preventDefault();
          mobileRollDice();
        });
        
        // Setup submit button - ONCE  
        const submitBtn = document.getElementById('mobileSubmitBtn');
        submitBtn.addEventListener('click', function(e) {
          e.preventDefault();
          mobileSubmitAnswer();
        });
        
        // Setup reload button - ONCE
        const reloadBtn = document.getElementById('mobileReloadBtn');
        reloadBtn.addEventListener('click', function(e) {
          e.preventDefault();
          location.reload();
        });
        
        // Setup enter key for answer - ONCE
        const answerInput = document.getElementById('mobileAnswerInput');
        answerInput.addEventListener('keypress', function(e) {
          if (e.key === 'Enter') {
            e.preventDefault();
            mobileSubmitAnswer();
          }
        });
        
        checkCanJoin();
      }
      
      function checkCanJoin() {
        const nameInput = document.getElementById('mobilePlayerName');
        const joinBtn = document.getElementById('mobileJoinBtn');
        
        if (nameInput && joinBtn) {
          const hasName = nameInput.value.trim().length > 0;
          const hasColor = myPlayerColor !== '';
          joinBtn.disabled = !(hasName && hasColor) || isJoining;
        }
      }
      
      function updateTakenColors(colors) {
        takenColors = colors;
        
        document.querySelectorAll('.mobile-color-option').forEach(option => {
          const color = option.dataset.color;
          
          if (takenColors.includes(color) && myPlayerColor !== color) {
            option.classList.add('disabled');
            option.classList.remove('selected');
          } else {
            option.classList.remove('disabled');
          }
        });
      }

      function joinMobileGame() {
        if (isJoining) return;
        
        const nameInput = document.getElementById('mobilePlayerName');
        myPlayerName = nameInput.value.trim();

        if (!myPlayerName) {
          showMobileError('Wpisz swoje imiƒô!');
          return;
        }

        if (!myPlayerColor) {
          showMobileError('Wybierz kolor!');
          return;
        }

        if (!myPeer || !myPeer.id) {
          showMobileError('Po≈ÇƒÖczenie nie jest gotowe. Spr√≥buj za chwilƒô.');
          return;
        }

        isJoining = true;
        checkCanJoin();

        try {
          hostConnection = myPeer.connect(roomId);
        } catch (error) {
          showMobileError('Nie mo≈ºna po≈ÇƒÖczyƒá: ' + error.message);
          isJoining = false;
          checkCanJoin();
          return;
        }

        hostConnection.on('open', function() {
          console.log('Connected to host');
          
          hostConnection.send({
            type: 'join',
            name: myPlayerName,
            color: myPlayerColor
          });
        });

        hostConnection.on('data', function(data) {
          handleHostMessage(data);
        });

        hostConnection.on('close', function() {
          alert('Po≈ÇƒÖczenie przerwane!');
          location.reload();
        });

        hostConnection.on('error', function(err) {
          console.error('Connection error:', err);
          isJoining = false;
          checkCanJoin();
          showMobileError('B≈ÇƒÖd po≈ÇƒÖczenia: ' + err.type);
        });
      }

      function handleHostMessage(data) {
        console.log('Received from host:', data);

        if (data.type === 'joined') {
          if (data.success) {
            isJoining = false;
            showMobileScreen('mobileWaitingScreen');
          }
        } else if (data.type === 'error') {
          isJoining = false;
          showMobileError(data.message);
        } else if (data.type === 'takenColors') {
          updateTakenColors(data.colors);
        } else if (data.type === 'gameStart') {
          allPlayers = data.players;
          currentTurn = data.currentPlayer;
          startMobileGame();
        } else if (data.type === 'yourTurn') {
          if (data.canRoll) {
            enableMobileRollButton();
          }
        } else if (data.type === 'turnUpdate') {
          currentTurn = data.currentPlayer;
          updateMobilePlayersList();
          updateMobileTurnMessage();
        } else if (data.type === 'diceRolled') {
          // Just update UI
        } else if (data.type === 'question') {
          showMobileQuestion(data);
        } else if (data.type === 'gameOver') {
          showMobileWinner(data.winner, data.winnerColor);
        }
      }

      function showMobileScreen(screenId) {
        const screens = document.querySelectorAll('.mobile-player-screen');
        screens.forEach(screen => {
          if (screen.id === screenId) {
            if (!screen.classList.contains('active')) {
              screen.classList.add('active');
            }
          } else {
            if (screen.classList.contains('active')) {
              screen.classList.remove('active');
            }
          }
        });
      }

      function showMobileError(message) {
        const errorDiv = document.getElementById('mobileJoinError');
        errorDiv.textContent = message;
        errorDiv.style.display = 'block';
        
        setTimeout(() => {
          errorDiv.style.display = 'none';
        }, 3000);
      }

      function startMobileGame() {
        showMobileScreen('mobileGameScreen');
        updateMobilePlayersList();
        updateMobileTurnMessage();
      }

      function updateMobilePlayersList() {
        const listContainer = document.getElementById('mobilePlayersList');
        if (!listContainer) return;

        const newHTML = '<strong style="font-size: 16px; display: block; margin-bottom: 10px;">Gracze:</strong>' +
          allPlayers.map((player, idx) => {
            const isCurrentTurn = idx === currentTurn;
            const colorDot = getPlayerColor(player.color);
            
            return `
              <div class="player-item ${isCurrentTurn ? 'current-turn' : ''}">
                <div class="player-color-dot" style="background: ${colorDot};"></div>
                <strong>${player.name}</strong>
                ${isCurrentTurn ? 'üëà' : ''}
              </div>
            `;
          }).join('');
        
        // Only update if changed
        if (newHTML !== lastPlayersListHTML) {
          listContainer.innerHTML = newHTML;
          lastPlayersListHTML = newHTML;
        }
      }

      function updateMobileTurnMessage() {
        const messageDiv = document.getElementById('mobileTurnMessage');
        if (!messageDiv) return;
        
        const myIndex = allPlayers.findIndex(p => p.name === myPlayerName && p.color === myPlayerColor);
        
        let newHTML;
        if (myIndex === currentTurn) {
          newHTML = '<strong style="color: #51cf66; font-size: 22px;">üé≤ TWOJA KOLEJ!</strong>';
        } else {
          newHTML = `Tura gracza: <strong>${allPlayers[currentTurn].name}</strong><br><span class="loading">Czekaj...</span>`;
        }
        
        // Only update if changed
        if (newHTML !== lastTurnMessageHTML) {
          messageDiv.innerHTML = newHTML;
          lastTurnMessageHTML = newHTML;
        }
      }

      function enableMobileRollButton() {
        const rollBtn = document.getElementById('mobileRollBtn');
        rollBtn.disabled = false;
        updateMobileTurnMessage();
      }

      function mobileRollDice() {
        const rollBtn = document.getElementById('mobileRollBtn');
        rollBtn.disabled = true;

        hostConnection.send({
          type: 'roll'
        });
      }

      function showMobileQuestion(data) {
        showMobileScreen('mobileQuestionScreen');
        
        document.getElementById('mobileQuestionText').textContent = data.question + ' = ?';
        document.getElementById('mobileAnswerInput').value = '';
        
        // Focus after a small delay to ensure screen is shown
        setTimeout(() => {
          document.getElementById('mobileAnswerInput').focus();
        }, 300);
        
        startMobileQuestionTimer(data.timeLimit);
      }

      function startMobileQuestionTimer(seconds) {
        if (mobileQuestionTimer) {
          clearInterval(mobileQuestionTimer);
        }

        let timeLeft = seconds;
        updateMobileTimerDisplay(timeLeft, seconds);

        mobileQuestionTimer = setInterval(() => {
          timeLeft--;
          updateMobileTimerDisplay(timeLeft, seconds);

          if (timeLeft <= 0) {
            clearInterval(mobileQuestionTimer);
            mobileSubmitAnswer();
          }
        }, 1000);
      }

      function updateMobileTimerDisplay(timeLeft, total) {
        const timerEl = document.getElementById('mobileTimer');
        const minutes = Math.floor(timeLeft / 60);
        const seconds = timeLeft % 60;
        timerEl.textContent = `${minutes}:${seconds.toString().padStart(2, '0')}`;

        timerEl.classList.remove('warning', 'danger');
        if (timeLeft <= 10) {
          timerEl.classList.add('danger');
        } else if (timeLeft <= total / 3) {
          timerEl.classList.add('warning');
        }
      }

      function mobileSubmitAnswer() {
        if (mobileQuestionTimer) {
          clearInterval(mobileQuestionTimer);
        }

        const answerInput = document.getElementById('mobileAnswerInput');
        const answer = answerInput.value;

        hostConnection.send({
          type: 'answer',
          answer: answer
        });

        showMobileScreen('mobileGameScreen');
        document.getElementById('mobileRollBtn').disabled = true;
      }

      function showMobileWinner(winnerName, winnerColor) {
        showMobileScreen('mobileWinnerScreen');
        const message = document.getElementById('mobileWinnerMessage');
        const colorHex = getPlayerColor(winnerColor);
        message.innerHTML = `<div style="font-size: 32px; margin: 20px 0;">üèÜ</div>` +
          `<strong style="color: ${colorHex}; font-size: 28px; text-shadow: 0 0 10px ${colorHex};">${winnerName}</strong>` +
          `<div style="font-size: 20px; margin-top: 10px;">WYGRYWA!</div>`;
      }
    </script>
  </body>
</html>
